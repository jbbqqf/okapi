from django.contrib.auth import login, logout
from django.core.exceptions import ObjectDoesNotExist

from rest_framework import status
from rest_framework.views import APIView
from rest_framework.authtoken.models import Token
from rest_framework.generics import GenericAPIView
from rest_framework.permissions import AllowAny
from rest_framework.authentication import TokenAuthentication
from rest_framework.response import Response
from rest_framework.decorators import permission_classes, authentication_classes

from okauth.serializers import LoginSerializer, TokenSerializer

@permission_classes((AllowAny,))
class LoginView(GenericAPIView):
    """
    === API endpoint to log in django users with django sessions ===
    """

    serializer_class = LoginSerializer

    def post(self, request):
        serializer = self.get_serializer(data=request.data)

        serializer.is_valid(raise_exception=True)

        user = serializer.validated_data['user']
        login(request, user)

        token, created = Token.objects.get_or_create(user=user)
        serialized_token = TokenSerializer(token)
        response_data = {
            'id': user.id,
            'username': serializer.data['username'],
            'token': serialized_token.data['key'],
        }
        return Response(response_data)

@permission_classes((AllowAny,))
class CheckTokenView(APIView):
    """
    === Check if your authent token is still in database ===

    Since it is possible to connect on multiple devices, any call to logout
    endpoint will destroy all token based authentications. This route is useful
    if you need to check whether or not your token is still valid.
    """

    def get(self, request):
        try:
            auth_headers = request.META.get('HTTP_AUTHORIZATION')
            auth_token = auth_headers.split(' ')
            assert (auth_token[0] == 'Token'), \
                "Token should be announced with a `Token ` string"

        except:
            message = {'message': 'No token supplied'}
            return Response(message, status=status.HTTP_400_BAD_REQUEST)

        try:
            Token.objects.get(key=auth_token[1])
            return Response(True)

        except ObjectDoesNotExist:
            return Response(False)

@permission_classes((AllowAny,))
class LogoutView(APIView):
    """
    === API endpoint to log out django users and destroy django sessions ===

    No argument is required to POST on this route. What it does is that it
    removes session information in cookie CSRF token generated by a previous
    login call.

    If no user is loged response is a 400 bad request.
    """

    def post(self, request):
        try:
            auth_headers = request.META.get('HTTP_AUTHORIZATION')
            auth_token = auth_headers.split(' ')
            assert (auth_token[0] == 'Token'), \
                "Token should be announced with a `Token ` string"

        except:
            message = {'message': 'No token supplied'}
            return Response(message, status=status.HTTP_400_BAD_REQUEST)

        try:
            token = Token.objects.get(key=auth_token[1])
            token.delete()
        except:
            message = {'message':
                'Could not delete supplied token. Check your supplied data.'}
            return Response(message, status=status.HTTP_400_BAD_REQUEST)

        logout(request)

        message = {'message': 'Successfully loged out'}
        return Response(message, status=status.HTTP_200_OK)
